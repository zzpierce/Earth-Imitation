<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <script src="scripts/lib/jquery.min.js"></script>
    <script src="scripts/lib/three.min.js"></script>
    <script src="scripts/controls/TrackballControls.js"></script>
    <script src="scripts/lib/dat.gui.js"></script>
    <script src="scripts/EarthModel.js"></script>
    <script src="scripts/SVGTranslator.js"></script>

    <script>
        var AmCharts = {};
        AmCharts.maps = {};
    </script>
    <script src="data/testmap/worldWithAntarcticaHigh.js"></script>
    <style>
        body{
            margin:0;
        }
        #container {
            margin:0;
        }
    </style>
</head>
<body>
<div id="container"></div>

</body>
<script>
    var WINDOW_H = window.innerHeight, WINDOW_W = window.innerWidth;
    var container;
    var scene, camera, renderer;
    var controller;

    //参数列表
    var lineLongitude = 30;     //经线数量
    var lineLatitude = 4;      //纬线数量
    var pts2d = [];     //构造地球的点的二维数组
    var pts1d = [];     //构造地球的点的一维数组

    var world = AmCharts.maps.worldWithAntarcticaHigh;
    var _path = world.svg.g.path;
    var mapRegion = world.svg.defs["amcharts:ammap"];

    var path = [];
    //顶点的三维数组
    var vertices = [];
    var svgMap = new SVGTranslator();
    var svgMesh = [];


    var xMax = 1008.27;
    var yMax = 1224;
    var toAngle = Math.PI / 180;
    var r = xMax * 180 / ( Math.PI * ( mapRegion.rightLongitude - mapRegion.leftLongitude ) );     //球体半径

    //earth model
    var earthModel = new EarthModel( r, 36 );


    init();
    animate();

    function init() {

        svgMap.translate( _path );
        initGUIPanel();

        container = document.getElementById("container");
        camera = new THREE.PerspectiveCamera(75, WINDOW_W / WINDOW_H, 1, 100000);
        scene = new THREE.Scene();
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0x000000);
        renderer.setSize(WINDOW_W, WINDOW_H);
        container.appendChild(renderer.domElement);
        controller = new THREE.TrackballControls(camera, container);
        controller.rotateSpeed = 5.0;

        draw();

        camera.position.z = 200;
        camera.position.x = 300;
        camera.position.y = 0;

        //init latitude and longitude
        var alpha, theta;
        var xi, yi;
        var xij, yij, zij;
        var vTmp;
        var pts2d = [];

        for( var i = 0; i < lineLatitude; i ++ ) {

            alpha = i / lineLatitude * Math.PI;
            xi = r * Math.sin( alpha );
            yi = r * Math.cos( alpha );
            pts2d[ i ] = [];

            for( var j = 0; j < lineLongitude; j ++ ) {

                theta = j / lineLongitude * 2 * Math.PI;
                zij = xi * Math.sin( theta );
                xij = xi * Math.cos( theta );
                yij = yi;
                vTmp = new THREE.Vector3( xij, yij, zij );
                pts2d[i].push( vTmp );
                pts1d.push( vTmp );
            }

        }

        //lights
        var lightD = new THREE.DirectionalLight( 0xFFFFFF, 0.7 );
        lightD.position.set( 100, 100, 0 );
        scene.add( lightD );

        var lightA = new THREE.AmbientLight( 0x666666 );
        scene.add( lightA );

        //init earth model
        earthModel.createMesh();
        var earthMesh = earthModel.earthMesh;

        for( var i = 0; i < earthMesh.lineMesh.length; i ++ ) {

            //scene.add( earthMesh.lineMesh[ i ] );

        }

        //load jpg
        earthModel.createFaceMesh( "data/textures/earth_atmos_4096.jpg", function(){

            scene.add( earthMesh.faceMesh );

        });

    }

    function draw() {

        var geometry;
        var material = new THREE.LineBasicMaterial( { color: 0xbbbbbb } );

        for( var i = 0; i < svgMap.vertices.length; i ++ ) {
            for( var j = 0; j < svgMap.vertices[ i].length; j ++ ) {

                geometry = new THREE.Geometry();
                geometry.vertices = svgMap.vertices[i][j];
                var mesh = new THREE.Line( geometry, material );
                svgMesh.push( mesh );

                scene.add( mesh );

            }
        }

    }

    function initGUIPanel() {

        var PanelText = function() {

            this.map1 = function() {

                scene.remove( earthModel.earthMesh.faceMesh );
                earthModel.createFaceMesh( "data/textures/earth_lights_2048.png", function(){

                    scene.add( earthModel.earthMesh.faceMesh );

                });

            };

            this.map2 = function() {

                scene.remove( earthModel.earthMesh.faceMesh );
                earthModel.createFaceMesh( "data/textures/earth_atmos_4096.jpg", function(){

                    scene.add( earthModel.earthMesh.faceMesh );

                });

            };

            this.map3 = function() {

                scene.remove( earthModel.earthMesh.faceMesh );
                earthModel.createFaceMesh( "data/textures/earth_specular_2048.jpg", function(){

                    scene.add( earthModel.earthMesh.faceMesh );

                });

            };


            this.bone = function() {

            };

            this.lineColor = "#bbbbbb";
        };

        var panel = new PanelText();
        var controlGUI = new dat.GUI();

        var mapFolder = controlGUI.addFolder( 'Choose Map');
        mapFolder.add( panel, 'map1' );
        mapFolder.add( panel, 'map2' );
        mapFolder.add( panel, 'map3' );
        
        var colorControl = controlGUI.addColor( panel, 'lineColor').listen();
        colorControl.onChange( function( value ) {

            for( i = 0; i < svgMesh.length; i ++ ){

                svgMesh[ i ].material.color = new THREE.Color( value );

            }

        } );

    }
    function animate() {

        requestAnimationFrame( animate );
        renderer.render( scene, camera );
        controller.update();

    }
</script>
</html>

