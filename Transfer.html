<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <script src="scripts/jquery.min.js"></script>
    <script src="scripts/three.min.js"></script>
    <script src="scripts/controls/TrackballControls.js"></script>
    <script>
        var AmCharts = {};
        AmCharts.maps = {};
    </script>
    <script src="data/testmap/worldLow.js"></script>
</head>
<body>
<div id="container"></div>

</body>
<script>
    var WINDOW_H = window.innerHeight, WINDOW_W = window.innerWidth;
    var container;
    var scene, camera, renderer;
    var controller;

    //参数列表
    var lineLongitude = 30;     //经线数量
    var lineLatitude = 30;      //纬线数量
    var pts2d = [];     //构造地球的点的二维数组
    var pts1d = [];     //构造地球的点的一维数组

    var world = AmCharts.maps.worldLow;
    var _path = world.svg.g.path;
    var mapRegion = world.svg.defs["amcharts:ammap"];

    var path = [];
    //顶点的三维数组
    var vertices = [];
    var xMax = 1008.27;
    var yMax = 650.94;
    var toAngle = Math.PI / 180;
    var r = xMax * 180 / ( Math.PI * ( mapRegion.rightLongitude - mapRegion.leftLongitude ) );     //球体半径

    var north = r * Math.tan( 83.68 * toAngle  );
    var south = r * Math.tan( 55.55 * toAngle );
    var total = north + south;

    test();
    function test() {
        var g = 20037508;
        var r = g / ( 2 * Math.PI );
        console.log(r);
        var l = r * Math.tan( 85.05 * toAngle );
        console.log( l * 2 );
    }

    translate();
    init();
    animate();

    function init() {

        container = document.getElementById("container");
        camera = new THREE.PerspectiveCamera(75, WINDOW_W / WINDOW_H, 1, 100000);
        scene = new THREE.Scene();
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0x000000);
        renderer.setSize(WINDOW_W, WINDOW_H);
        container.appendChild(renderer.domElement);
        controller = new THREE.TrackballControls(camera, container);
        controller.rotateSpeed = 5.0;

        draw();

        camera.position.z = 700;
        camera.position.x = 300;
        camera.position.y = 0;
    }

    //将SVG格式的坐标转为数组格式
    function translate() {
        var pathLen = _path.length;
        for( var i = 0; i < pathLen; i ++ ) {
            var d = _path[ i ].d;
            var _d = d.split(/([^\d\.-]+)/);
            path.push( _d );

//            for( var j=0;j<_d.length;j++){
//                if(_d[j] == "zm" || _d[j] == "zM" || _d[j] == 'm' )console.log(_d[j]);
//            }
        }


        //console.log(path);
        var nowX, nowY;
        for( i = 0; i < path.length; i ++ ) {
            vertices[ i ] = [];
            var k = -1;
            for( var j = 0; j < path[ i ].length; j++ ) {
                switch( path[ i ][ j ] ){
                    case 'M':
                    case 'zM':
                        k ++;
                        vertices[i][k] = [];
                        nowX = parseFloat( path[i][j+1] );
                        nowY = parseFloat( path[i][j+3] );
                        vertices[ i][k].push( new THREE.Vector3( nowX, nowY, 0) );
                        j += 3;
                        break;
                    case 'L':
                        nowX = parseFloat( path[i][j+1] );
                        nowY = parseFloat( path[i][j+3] );
                        vertices[ i][k].push( new THREE.Vector3( nowX, nowY, 0) );
                        j += 3;
                        break;
                    case 'H':
                        nowX = parseFloat( path[i][j+1] );
                        vertices[i][k].push( new THREE.Vector3( nowX, nowY, 0));
                        j += 1;
                        break;
                    case 'V':
                        nowY = parseFloat( path[i][j+1] );
                        vertices[i][k].push( new THREE.Vector3( nowX, nowY, 0));
                        j += 1;
                        break;
                    case 'l':
                        nowX = parseFloat( nowX ) + parseFloat( path[i][j+1] );
                        nowY = parseFloat( nowY ) + parseFloat( path[i][j+3] );
                        vertices[ i][k].push( new THREE.Vector3( nowX, nowY, 0) );
                        j += 3;
                        break;
                    case 'h':
                        nowX = parseFloat( nowX ) + parseFloat( path[i][j+1] );
                        vertices[ i][k].push( new THREE.Vector3( nowX, nowY, 0) );
                        j += 1;
                        break;
                    case 'v':
                        nowY = parseFloat( nowY ) + parseFloat( path[i][j+1] );
                        vertices[i][k].push( new THREE.Vector3( nowX, nowY, 0));
                        j += 1;
                        break;
                    default: break;
                }
            }
        }

        //console.log(vertices);
        for( i = 0; i < vertices.length; i ++ ) {
            for( j = 0; j < vertices[i].length; j ++ ) {
                for( k = 0; k < vertices[i][j].length; k ++ ) {
                    vertices[i][j][k] = mapping( vertices[i][j][k] );
                }
            }
        }
    }

    //将二维坐标转为球形地图的坐标
    function mapping( v3 ) {

//        var tanAlpha = ( v3.y - 800 ) / r;
//        var alpha = Math.PI - Math.atan( tanAlpha );

        var xe = - v3.x * ( mapRegion.rightLongitude - mapRegion.leftLongitude ) / xMax;
        //var ye = v3.y * ( mapRegion.topLatitude - mapRegion.bottomLatitude ) / yMax + 90 - mapRegion.topLatitude;

        //var alpha = ye * toAngle;
        var alpha = Math.atan2( r, 480 - v3.y);
        var theta = xe * toAngle;

        var xTmp = r * Math.sin( alpha );
        var y = r * Math.cos( alpha );
        var x = xTmp * Math.cos( theta );
        var z = xTmp * Math.sin( theta );

        return new THREE.Vector3( x, y, z );
    }

    function draw() {
        var geometry;
        var material = new THREE.MeshBasicMaterial( { color: 0x66CCFF } );
        for( var i = 0; i < vertices.length; i ++ ) {
            for( var j = 0; j < vertices[ i].length; j ++ ) {
                geometry = new THREE.Geometry();
                geometry.vertices = vertices[i][j];
                scene.add( new THREE.Line( geometry, material ) );
            }
        }
    }

    function animate() {

        requestAnimationFrame( animate );
        renderer.render( scene, camera );
        controller.update();

    }
</script>
</html>

